/*
	Madd Development Tools

	Copyright (c) 2017, Madd Games.
	All rights reserved.
	
	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	
	* Redistributions of source code must retain the above copyright notice, this
	  list of conditions and the following disclaimer.
	
	* Redistributions in binary form must reproduce the above copyright notice,
	  this list of conditions and the following disclaimer in the documentation
	  and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "liblex.h"

/**
 * PROTOTYPE FOR PARSER FUNCTION:
 *	<unitName>_<symbolName>_t* <unitName>_<symbolName>(Token *toklist, Token **tokOut, char **error);
 *
 * Attempts to match a symbol at the specified token list head. Returns NULL on failure, or a parse tree on
 * success. Also on success, it sets 'tokOut' to the head of tokens following this symbol (never NULL; but
 * may be empty so plNext() will return NULL in this case). Also on failure it sets 'error' to an error string
 * allocated on the heap.
 */

#define	ERROR_PRINTER "if (toklist != NULL)\n{\n\
		size_t errsz = sprintf(NULL, \"%s:%d: %s\", toklist->filename, toklist->lineno, errmsg);\n\
		*error = (char*) malloc(errsz+1);\n\
		sprintf(*error, \"%s:%d: %s\", toklist->filename, toklist->lineno, errmsg);\n\
	}\nelse\n{\n\
		size_t errsz = sprintf(NULL, \"<EOF>: %s\", errmsg);\n\
		*error = (char*) malloc(errsz+1);\n\
		sprintf(*error, \"<EOF>: %s\", errmsg);\n};\nreturn NULL;"

enum
{
	TOK_SYMBOL,
	TOK_DIR,
	TOK_LITERAL,
	TOK_OP
};

TokenSpec tokenSpecs[] = {
	// first comments and whitespaces
	{-1,			"$*"},
	{-1,			"\\/\\/.*?\n?"},
	{-1,			"\\/\\*.*?(\\*\\/)"},

	// now actual tokens
	{TOK_SYMBOL,		"\\<[-a-zA-Z0-9]+\\>"},
	{TOK_DIR,		"[_a-zA-Z][_a-zA-Z0-9]*"},
	{TOK_LITERAL,		"\\'.*?\\'"},
	{TOK_OP,		"(\\;|\\:\\:\\=)"},
	
	// terminator
	{0, NULL}
};

void errormsg(Token *tok, const char *msg)
{
	if (tok == NULL)
	{
		fprintf(stderr, "<EOF>: %s\n", msg);
	}
	else
	{
		fprintf(stderr, "%s:%d: %s\n", tok->filename, tok->lineno, msg);
	};
};

void parseSym(char *put, const char *spec)
{
	for (spec++; *spec!='>'; spec++)
	{
		if (*spec == '-')
		{
			*put++ = '_';
		}
		else
		{
			*put++ = *spec;
		};
	};
	
	*put = 0;
};

int main(int argc, char *argv[])
{
	// read the grammar into memory
	char buffer[2048];
	char *data = (char*) malloc(1);
	size_t sz = 0;
	size_t nextSize;
	
	while ((nextSize = fread(buffer, 1, 2048, stdin)) != 0)
	{
		data = (char*) realloc(data, sz + nextSize + 1);
		memcpy(&data[sz], buffer, nextSize);
		sz += nextSize;
	};
	
	// tokenize
	int errnum = lexCompileTokenSpecs(tokenSpecs);
	assert(errnum == 0);
	Token *toklist = (Token*) plCreate(sizeof(Token));
	char *error = lexTokenize(toklist, argv[0], data, tokenSpecs);
	if (error != NULL)
	{
		fprintf(stderr, "%s\n", error);
		return 1;
	};
	
	const char *unitName = NULL;
	
	// compile it all
	while (toklist != NULL)
	{
		toklist = (Token*) plNext((Pipeline*) toklist);
		if (toklist == NULL) break;
		
		if (strcmp(toklist->value, "unit") == 0)
		{
			if (unitName != NULL)
			{
				errormsg(toklist, "unit name must only be declared once");
				return 1;
			};
			
			toklist = (Token*) plNext((Pipeline*) toklist);
			if (toklist == NULL)
			{
				errormsg(toklist, "expecting a unit name");
				return 1;
			};
			if (toklist->type != TOK_DIR)
			{
				errormsg(toklist, "unit name must be a directive word");
				return 1;
			};
			
			unitName = toklist->value;
			
			toklist = (Token*) plNext((Pipeline*) toklist);
			if (toklist == NULL)
			{
				errormsg(toklist, "expecting ';'");
				return 1;
			};
			
			if (strcmp(toklist->value, ";") != 0)
			{
				errormsg(toklist, "expecting ';'");
				return 1;
			};
			
			printf("/* automatically generated by bnfc for unit '%s' - DO NOT EDIT! */\n", unitName);
			printf("#include \"%s.h\"\n", unitName);
			printf("#include \"liblex.h\"\n");
			printf("#include <stdio.h>\n\n");
		}
		else if (unitName == NULL)
		{
			errormsg(toklist, "BNF file must begin with a unit name declaration");
			return 1;
		}
		else if (strcmp(toklist->value, "terminal") == 0)
		{
			toklist = (Token*) plNext((Pipeline*) toklist);
			if (toklist == NULL)
			{
				errormsg(toklist, "expecting a terminal symbol name");
				return 1;
			};
			if (toklist->type != TOK_SYMBOL)
			{
				errormsg(toklist, "expecting a terminal symbol name");
				return 1;
			};
			
			const char *symspec = toklist->value;
			char symname[strlen(toklist->value)+1];
			parseSym(symname, toklist->value);
			
			toklist = (Token*) plNext((Pipeline*) toklist);
			if (toklist == NULL)
			{
				errormsg(toklist, "expecting 'from' keyword");
				return 1;
			};
			if (strcmp(toklist->value, "from") != 0)
			{
				errormsg(toklist, "expecting 'from' keyword");
				return 1;
			};
			
			toklist = (Token*) plNext((Pipeline*) toklist);
			if (toklist == NULL)
			{
				errormsg(toklist, "expecting a token type macro");
				return 1;
			};
			if (toklist->type != TOK_DIR)
			{
				errormsg(toklist, "expecting a token type macro");
				return 1;
			};
			
			const char *macro = toklist->value;
			
			toklist = (Token*) plNext((Pipeline*) toklist);
			if (toklist == NULL)
			{
				errormsg(toklist, "expecting ';'");
				return 1;
			};
			
			if (strcmp(toklist->value, ";") != 0)
			{
				errormsg(toklist, "expecting ';'");
				return 1;
			};
			
			// generate terminal matcher code
			printf("// %s\n", symspec);
			printf("%s_%s_t* %s_%s(Token *toklist, Token **tokOut, char **error)\n",
				unitName, symname, unitName, symname);
			printf("{\n");
			printf("\tconst char *errmsg = \"expected %s\";\n", symspec);
			
			// the code must first try to get a token and ensure it's non-NULL
			printf("\ttoklist = (Token*) plNext((Pipeline*) toklist);\n");
			printf("\tif (toklist == NULL)\n");
			printf("\t{\n");
			printf("\t\t%s;\n\t};\n", ERROR_PRINTER);
			
			// then check if the type is correct
			printf("\tif (toklist->type != %s)\n", macro);
			printf("\t{\n\t\t%s;\n\t};\n", ERROR_PRINTER);
			
			// we have a match
			printf("\t%s_%s_t *result = (%s_%s_t*) malloc(sizeof(%s_%s_t));\n",
				unitName, symname, unitName, symname, unitName, symname);
			printf("\tresult->filename = toklist->filename;\n");
			printf("\tresult->lineno = toklist->lineno;\n");
			printf("\tresult->col = toklist->col;\n");
			printf("\tresult->value = toklist->value;\n");
			printf("\treturn result;\n");
			
			// end of the function
			printf("};\n\n");
		}
		else
		{
			errormsg(toklist, "unexpected token");
			return 1;
		};
	};
};
